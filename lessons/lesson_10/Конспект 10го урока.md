# Урок 10

## Force click и мульти-поиск

### Методы взаимодействия с браузером
#### Методы, которые мы изучили ранее:
1. **find_element** - Поиск элемента
2. **find_elements** - Поиск элементов (по неуникальному локатору):
   1. Проверка равенства количества элементов
   2. Проверка неравенства количества элементов
3. **exist** - Проверка на то, есть ли элемент в DOM
4. **not exist** - Проверка на то, нет ли элемент в DOM
5. **visible** - Проверка на то, виден ли элемент на странице
6. **not visible** - Проверка на то, НЕ виден ли элемент на странице
7. **get_text** - Получить текст элемента
8. **click** - Кликнуть на элемент

#### Методы, которые мы изучим на этот уроке
1. **click_force** - Кликнуть на элемент принудительно (если элемент скрыт, или элемент не кликабельный)
2. **send_keys** - Ввести текст
3. **clear** - Очистить текстовое поле
4. **get_attribute** - Получение атрибута элемента

### Задача 7 из 9-го урока (мы тогда её не смогли решить)
Допустим, есть тест кейс:
1. На странице demoqa.com/automation-practice-form
2. Проверьте, что модальное окно закрыто
3. Заполните форму и отправьте её
4. Проверьте открытие модального окна после отправки формы

На 9-м уроке у нас возникала ошибка "...exceptions.ElementClickInterceptedException"
Элемент не кликабельный.
1. Эта ошибка выдаётся потому, что элемент не кликабельный.
Данная ошибка подразумевает, что нужный элемент не был кликабельным, так как какой-то другой элемент скрывает его.
2. У этой проблемы есть 2 решения:
    1. Если ситуация динамическая, можно поставить ожидание, пока нужный нам элемент не станет кликабельным.
    2. Сделать принудительный клик

### Метод click_force()
click_force() - это кастомный метод для принудительного клика
execute_script() - это метод API Selenium, позволяющий добавлять свой JS-код
execute_script(скрипт, *аргументы)
Синхронно выполняет JavaScript-код в текущем окне.

### Решение предыдущей задачки, чтобы устранить ошибку
1. В классе WebElement, после метода click(), добавьте метод click_force():
   1. Метод click_force() принимает только self
   2. В теле метода обратитесь к драйверу, от него вызовите метод execute_script()
   3. В методе execute_script() первым аргументом передайте следующий JavaScript код:
      1. "arguments[0].click();"
   4. Вторым методом вызовите метод find_elements()


        def click_force(self):
            self.driver.execute_script("arguments[0].click();", self.find_elements())
2. Вернитесь в файл test_login_form.py:
   1. Измените оба метода клика на click_force()
   2. Запустите - ошибки нет.
   3. Также добавьте проверку на наличие modal_dialog
   4. В конце добавьте принудительный клиент по btn_close_modal
   5. Запустите тест кейс

### Задача 2
1. В файле test_login_form.py допишите тест:
   1. Заполните поля на форме страницы (произвольными данными)
      1. Hobbies
      2. Current Address

### Метод clear()
Реализуем кастомный метод, который будет очищать поля.
1. В классе WebElement добавьте импорт from selenium.webdriver.common.keys import Keys
2. Добавьте метод clear(), метод принимает только self.
3. В теле метода добавьте:
   1. Вызовите метод find_element() и от него метод send_keys(), в последний передайте Keys.CONTROL + 'a'
   2. Повторите строчку и передайте Keys.DELETE
С помощью объекта Keys можно передать в поле любое сочетание клавиш.
   

      def cleat(self):
         self.find_element().send_keys(Keys.CONTROL + 'a')
         self.find_element().send_keys(Keys.DELETE)

### Задача 3
1. Создайте тестовый файл test_clear.py, в нём одноименную функцию, реализуйте тест кейс:
   1. Перейти на страницу demoqa.com/text-box
   2. Ввести в первое поле произвольный текст
   3. Подождать 2 секунды
   4. Очистить поле
   5. Подождать 2 секунды
   6. Проверить, что в первом поле пусто

### Задача 4* (со звёздочкой)
1. Подумайте, как можно заполнить поле "State and City"? (это выпадающий список).
Это задачка на подумать. Мы его разберём на занятии № 11.

### Атрибуты элементов
У элементов HTML есть атрибуты.
Это дополнительные значения, которые настраивают элементы или регулируют их поведение различным способом.

### Метод get_dom_attribute()
Метод get_dom_attribute(name) -> str or None.
Метод получает себе имя атрибута и возвращает строку или ничего.
Этот метод возвращает значение атрибутов с заданным именем.
Если у заданного атрибута нет значения - возвращается '' - пустая строка.
Если атрибута с таким именем нет - возвращается None.

### Что делаем? 
В классе WebElement создайте метод get_dom_attribute()

### Задача 5
1. Создайте тестовый файл test_attribute.py, в файле создайте тест test_placeholder, реализуйте тест кейс:
   1. Перейти на страницу demoqa.com/text-box
   2. Проверить, что у элемента Full Name есть атрибут placeholder со значением 'Full Name'

### Метод get_by_type()
Сейчас все наши методы по работе с элементами заточены на работу с CCS.SELECTOR.
Реализуем метод для работы с любым типом локатор.
1. В классе WebElement добавьте метод get_by_type(self):
   1. Добавить саму функцию
   2. Прописать переменную locator_type в классе WebElements
   3. Заменить все By.CSS_SELECTOR на вызов метода self.get_by_type():
      1. В функции find_element,
      2. В функции find_elements

### Метод scroll_to_element()
Метод реализует метод прокрутки страницы до любого элемента. В классе WebElement добавьте тод scroll_to_element(self):
1. В теле метода self.driver.execute_script()
2. И передаём 2 аргумента:
   1. "windows.scrollTo(0, document.body.scrollHeight);"
   2. self.find_element()