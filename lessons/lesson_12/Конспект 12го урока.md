# Урок 12

## Алерты, вкладки и декораторы

## Диалоговые окна - alert, prompt и confirm (начали проходить на 11-ом уроке)
1. **alert** - выводит сообщение
2. **prompt** - выводит сообщение и ждёт, пока пользователь введёт текст, а затем возвращает введённое значение или null, если ввод был отменён (CANCEL/Esc)
3. **confirm** - выводит сообщение и ждёт, пока пользователь нажмёт "ОК" или "CANCEL" и возвращает True/False

Диалоговые окна не являются частью страницы. Они являются частью браузера.
Такое окно всегда одно на странице, даже если их несколько они вызываются асинхронно, что позволяет нам работать одним методом со всеми типами окон.
В Selenium для этого существует метод:
**browser.switch_to.alert**
Метод возвращает объект окна.

### Метод switch_alert()
Добавим метод alert в базовый класс страниц.
Метод принимает только self и возвращает получение объекта окна browser.switch_to.alert

      def alert(self):
         teturn self.driver.switch_to.alert

Такой метод позволяет нам проверить открыть ли алерт  и даёт возможность работать с окном, но не позволяет проверить, что окно НЕ открыто.
Нам необходимо дополнить этот метод:
      
      import logging

      def alert(self):
         try:
            return self.driver.switch_to.alert
         except Exception as ex:
            logging.log(1, ex)
            return False

### Задание №1 
1. Реализуйте тест кейс:
   1. Перейти на страницу demoqa.com/alerts:
      1. Создайте класс страницы alerts.py
      2. Создайте тестовый файл и тестовую функцию test_alert.py
      3. Создайте объект страницы от класса
      4. Вызовите метод входа на страницу
   2. Проверить, что нет активного алерта:
      1. Вызовите метод alert() от объекта страницы
      2. Сделайте отрицание проверки
   3. Нажать на кнопку вызова алерта "#alertButton"
   4. Подождать 2 секунды
   5. Проверить наличие алерта:
      1. Вызовите метод alert() от объекта страницы с обычной проверкой

### Проверки Alert
Также для любого окна мы можем сделать следующие вещи:
1. Проверить текст в окне:
   1. Получить текст можно вызвав **.text** от объекта окна
2. Подтвердить alert:
   1. Подтвердить alert можно вызвав **accept()** от объекта окна.
3. Для этих проверок мы не будем создавать отдельные методы. Мы будем вызывать их прямо в тесте.

### Задание №2 (на тип алертов Alert)
1. В тот же файле, test_alert.py, реализуйте следующий тест кейс:
   1. Перейти на страницу demoqa.com/alerts
   2. Нажать на кнопку вызова алерта "#alertButton"
   3. Подождать 2 секунды
   4. Проверить, что текст в окне == "You clicked a button"
   5. Подтвердить алерт
   6. Проверить, что нет активного алерта

### Тип алертов Confirm
В окнах confirm добавляется кнопку "ОТМЕНА", все остальные проверки для такого окна будут проходить также, как в alert.
Отменить действие можно вызвав **dismiss()** от объекта окна.

### Задание №3 (на тип алертов Confirm)
1. В тот же файле, test_alert.py, реализуйте следующий тест кейс:
   1. Перейти на страницу demoqa.com/alerts
   2. Нажать на кнопку вызова алерта "#confirmButton"
   3. Подождать 2 секунды
   4. Отменить действие в окне:
      1. Вызвать dismiss() от объекта окна
   5. Проверить, что текст в блоке "#confirmResult" == "You selected Cancel"

### Тип алертов Prompt
В окнах prompt добавляется поле для ввода, все остальные проверки для такого окна будут проходить также, как в предыдущих.
Ввести текст в окно можно вызвав send_keys('') от объекта окна. И передав в метод текст, который требуется ввести.

### Задание №4 (на тип алертов Prompt)
1. В тот же файле, test_alert.py, реализуйте следующий тест кейс "test_prompt":
   1. Перейти на страницу demoqa.com/alerts
   2. Нажать на кнопку вызова алерта "#promptButton"
   3. Подождать 2 секунды
   4. Ввести своё имя в текстовое поле:
      1. Вызвав send_keys ("name") от объекта окна
   5. Проверить, что текст в блоке #promptResult == "You entered {NAME}"

## Работа с вкладками в Selenium
1. Создайте класс browser_tab.py страницы demoqa.com/browser-windows
   1. В нём создайте элемент new_tab с локатором "#tabButton"

### Задание №5 (работа с вкладками)
1. Создайте текстовый файл test_browser_tab.py
2. Создайте тест кейс test_browser_tab(browser)
3. В тест кейса сделайте вход на страницу browser_tab

### Метод .windows_handles
В Selenium есть метод для получения списка открытых вкладок:
**driver.window_handles**
Тут мы обращаемся к Браузеру, а не к нашей странице.

Дополним им наш предыдущий тест кейс

### Задание №6 (дополняем тест кейс методом window_handles())
1. Дополняем наш предыдущий тест кейс:
   1. После входа на страницу, получите список вкладок и проверьте, что длинна == 1
   2. Сделайте клик по кнопке new_tab
   3. Подождите 2 секунды
   4. Получите список вкладок и проверьте, что длина == 2

### Метод switch_to.window()
Также мы можем принудительно перейти на любую вкладку.
Для этого есть метод driver.switch_to.window().
В этот метод мы должны передать объект вкладки в которую хотим перейти.

Дополним им наш предыдущий тест кейс.

### Задание №7 (дополняем тест кейс методом switch_to.window())
1. Дополняем наш предыдущий тест кейс:
   1. Вызовите метод switch_to.window() от объекта browser
   2. Передайте в метод объект первой вкладки browser.window_handles[0]
   3. Поставьте ожидание на 2 секунды

## Один тест на несколько страниц (декораторы pytest)
Декоратор - это то, что позволяет нам менять поведение функции, вне этой функции.
Допустим, есть тест кейс, в котором требуется проверить на нескольких страницах:
1. title на странице соответствует page.get_title() == 'DEMOQA'
У pytest есть декоратор @pytest.mark.parametrize() для цикличных тестов с разными переменными.
2. Следовательно, мы можем передать классы страниц, как переменную для теста.

### Задание №8 (реализовываем тест кейс с декоратором)
1. Откройте файл test_seo.py
2. Добавьте тест кейс 
3. Импортируйте используемые страницы:


      @pytest.mark.parametrize("pages", [Accordion, Alerts, DemoQa, BrowserTab])
      def test_check_title_all_pages(browser, pages):
         page = pages(browser)
4. Сделайте вход на страницу
5. Поставьте слип на 2 секунды
6. Сделайте проверку:
   1. Сравните title со страницы page.get_title() == 'DEMOQA'

### Задача №9 (реализовать тест кейс)
1. Создайте файл test_seo_meta.py, автоматизируйте тест кейс:
   1. На страницах Accordion, Alerts, DemoQa, BrowserTab:
   2. есть мета тег "head > meta"
      1. Эл мент присутствует на всех страницах, тест требуется только для указанных.
   3. У тега есть следующие атрибуты:
      1. name = "viewport"
      2. content = "width=device-width, initial-scale=1"
   4. P.S. Подумайте, где нужно создать элемент?