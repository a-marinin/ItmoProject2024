# Урок 9

## Задачки на методы 8го занятия. А также добавление новых методов для работы с браузером и элементами. 

### Навигация по браузеру
#### Методы и атрибуты для работы с браузером, предоставляемые API Selenium:
1. .current_url - получить текущий URL страницы
2. .get() - Перейти по URL
3. .title - Получить title страницы
4. .back() - Перейти назад (стрелка назад в браузере)
5. .forward() - Перейти вперёд (стрелка вперёд в браузере)
6. .refresh() - Обновить страницу
7. .set_windows_size() - Установить размер страницы

### Задача 1
Создайте тестовый файл test_navigation.py
В нём реализуйте следующий тест кейс: def test_navigation(browser):
1. Зайти на страницу DemoQa:
   1. Создайте объект класса страницы 
   2. От объекта вызовите метод входа
2. Через кнопку btn_elements попасть на страницу ElementsPage:
   1. Обратитесь к странице - к элементу - вызовите метод .click()  
3. Вызвать обновление страницы от объекта страницы
4. Вызвать обновление страницы от browser.
5. Вызвать back() от browser
6. Вызвать forward() от browser
7. От объекта страницы ElementsPage вызвать .equal_url()
INFO: forward(), back(), refresh() - можно вызывать как от объекта страница, так и от browser.

### Задача 2
Создайте тестовый файл test_seo.py
В нём реализуйте следующий тест кейс:
1. Зайти на страницу DemoQa:
   1. Создайте объект класса страницы
   2. От объекта вызовите метод входа
2. Получите title от браузера и сравните с эталоном:
   1. Эталонный вариант возьмите с сайта

### Метод .set_window_size(width=W, height=H)
Метод, который устанавливает размеры страницы, где:
W - ширина окна браузера
H - высота окна браузера

Например:

      browser.set_window_size(width=1000, height=300) 
      # Устанавливаем размеры окна ширина 1000 и высотой 300.
**ВАЖНО**: Драйвер сам не возвращает размеры окна между тестами. Т.е. если вы уменьшили размер для одного теста, его нужно явно вернуть после теста, иначе все последующие тесты пройдут в уменьшенном окне.

### Задача 3
Установить размер браузера по-умолчанию в файле фикстур conftest.py:
1. Откройте файл фикстур conftest.py
2. После создания объекта драйвера и перед его использованием (yield), установите размеры окна:
- browser.set_window_size(width=1000, height=1000) 

### Задача 4
Создайте тестовый файл test_size.py и реализуйте в нём тест кейс:
1. Зайти на страницу DemoQa:
   1. Создайте объект класса страницы
   2. От объекта вызовите метод входа
2. Установите размеры окна width=1000, height=300:
   1. Вызвав .set_windows_size() от браузера
3. Поставьте задержку на 2 секунды
4. Установите размеры width=1000, height=1000 - тем самым вернув их в исходное состояние

### Метод .find_elements(By."TYPE", locator)
Ранее мы использовали метод find_element (т.е. искали какой-то конкретный элемент по уникальному локатору).
Теперь мы научимся искать несколько элементов по не уникальному локатору.
Бывают тест кейсы, когда необходимо получить несколько элементов.
Например: 
1. Проверить количество элементов
2. Сделать 1 тест над несколькими элементами

Для этого в API Selenium есть метод **find_elements(By."TYPE".locator)**, где:
**By."TYPE"** - в нашем случае By.CSS_SELECTOR - тип поиска элемента
**locator** - локатор элементОВ.
Функция возвращает список веб-элементов, найденных по локатору.

### Задача 5
В класс WebElement, после метода find_element, добавьте метод find_elements.
Методы отличаются только названием функции find_element -> find_elementS.

### Метод .check_count_elements()
Это первый метод при работе с методом find_elements.
Для этого реализуем метод для проверки количества одинаковых элементов на странице:
1. В класс WebElement добавьте метод check_count_elements:
   1. Метод принимает (self, count: int)
   2. Если длина self.find_elements() равна переменной count, - то метод возвращает True
   3. Во всех других случаях метод возвращает False

### Задача 6
1. Создайте файл test_elements.py, в файле создайте тест кейс def test_find_elements():
   1. Зайти на страницу ElementsPage
   2. Проверить, что элементов с локатором "div:nth-child(1) > div > ul > li" - 9 штук
      (создавая элемент на странице дайте ему название btns_first_menu)

### Метод .send_keys() - Ввод текста
send_keys(*value) -> None:
1. value - это значение, которое нужно записать
2. Метод ничего не возвращает -> None
3. Вызывается от .find_element()

Пример: 


     driver.find_element(By.CSS_SELECTOR, 'username').send_keys("admin")

Где этот метод может применяться? 
### Задача 7
Допустим, есть тест кейс:
1. На странице demoqa.com/automation-practice-form
2. Проверьте, что модальное окно закрыто
3. Заполните форму и отправьте её
4. Проверьте открытие модального окна после отправки формы

Автоматизируем его по следующему алгоритму:
1. Создайте новый файл класса страницы form_page.py
2. Создайте класс для новой страницы demoqa.com/automation-practice-form FormPage:
   1. По аналогии с другими классами страниц.
3. В новый класс ElementsPage добавьте следующие элементы страницы:
   1. first_name - локатор '#firstName'
   2. last_name - локатор '#lastName'
   3. user_email - локатор '#userEmail'
   4. gender_radio_1 - локатор '#gender-radio-1'
   5. user_number - локатор '#userNumber'
   6. btn_submit - локатор '#submit'
   7. modal_dialog - локатор 'body > div.fade.modal.show > div'
   8. btn_close_modal - локатор '#closeLargeModal'
4. Добавим метод send_keys:
   1. В классе WebElement добавьте новый метод send_keys()
   2. Метод send_keys() принимает self и переменную text типа str
   3. В теле метода send_keys(), обратитесь к методу find_elements и от него вызовете метод send_keys().
   4. В метод send_keys() передайте переменную text
5. Создадим новый тест кейс test_login_form.py:
   1. Аналогично назовите тест, передайте в него browser
   2. Импортируйте ксс страницы FormPage
   3. Создайте объект form_page, как экземпляр класса FormPage, при создании передайте в класс browser.
   4. Перейти на страницу:
      1. Вызовите метод входа для объекта страницы.
   5. Методом exist() проверьте отсутствие modal_dialog.
   6. После поставьте ожидание на 2 секунды.
   7. Заполните следующие поля:
      1. ...first_name.send_keys('tester')
      2. ...last_name.send_keys('testerovich')
      3. ...user_email.send_keys('test@ttt.tt')
      4. ...gender_radio_1.click()
      5. user_number.send_keys('9999999999')
   8. Поставьте ожидание на 2 секунды 
   9. Нажмите на кнопку отправки btn_submit
   10. Поставьте ожидание на 2 секунды
   11. Запустите тест
   12. Выдаётся ошибка "...exceptions. ElementClickInterceptedException"
       1. Эта ошибка выдаётся потому, что элемент не кликабельный.
       Данная ошибка подразумевает, что нужный элемент не был кликабельным, так как какой-то другой элемент скрывает его.
       2. У этой проблемы есть 2 решения:
           1. Если ситуация динамическая, можно поставить ожидание, пока нужный нам элемент не станет кликабельным.
           2. Сделать принудительный клик
