# Урок 8

## Визуализация POM

### Что мы реализовали до 7го урока?
    - У нас есть класс страницы (DemoQa), который наследуется от базового класса всех страни (BasePage).
    - У класса DemoQa есть какие-то атрибуты, которые являются объектами класса WebElement:
        - btn_element, icon - это всё ебъекты нашего класса WebElement
        - Когда мы создаём объект класса страницы, - мы передаём ему browser (demo_qa_page = DemoQa(browser)).
        (сам браузер передаэтся метод инициализации в наш конструктор, а сам браузер мы передаём из теста).

Мы реализовали набор инструментов, которыми просто пользуемся. Эти инструменты мы можем переиспользовать многократно. 

### Что мы всегда делаем в тестах?
 - Шаг №1: Мы всегда создаём объект нашей страницы (нашего класса страницы) и передаём туда browser.
 - Шаг №2: Мы обращаемся уже к этому объекту (страницы), вызываем метод visit().
 - Шаг №3: Мы обращаемся к объекту нашей страницы, обращаемся к атрибуту (например, icon), и вызываем метод WebElement (например, click)
 - Шаг №4: Используя ключевое слово assert мы проверяем какие-то методы, какие-то функции, какие-то вещи

Пример:

    demo_qa_page = Demoqa(browser)
    ├── demo_qa_page - visit()
    ├── demo_qa_page - icon - click()   
    ├── assert - demo_qa_page - equal_url()
    ├── assert - demo_qa_page - icon - exist()

## Инструменты автоматизации - API Selenium
С помощью следующих инструментов можно организовать примерно 90% автотестов:
1. Функции взаимодействия с **браузером**
2. Функции взаимодействия с **элементами на странице**
3. Функции взаимодействия с **API** (запросы, ответы, статусы ответа, заголовки)
4. Функции взаимодействия с **Alerts, Confirm, Prompt**
5. Функции взаимодействия с **окнами и вкладками**
6. Взаимодействие с файлами **cookie** 
7. Исключения
8. Mocks
9. Кэш приложения
10. Прокси

### Навигация по браузеру
#### Методы и атрибуты для работы с браузером, предоставляемые API Selenium:
1. .current_url - получить текущий URL страницы
2. .get() - Перейти по URL
3. .title - Получить title страницы
4. .back() - Перейти назад (стрелка назад в браузере)
5. .forward() - Перейти вперёд (стрелка вперёд в браузере)
6. .refresh() - Обновить страницу
7. .set_windows_size() - Установить размер страницы

#### Взаимодействие с элементами на странице:
1. **find_element** - Поиск элемента
2. **find_elements** - Поиск элементов (по неуникальному локатору):
   1. Проверка равенства количества элементов
   2. Проверка неравенства количества элементов
3. **exist** - Проверка на то, есть ли элемент в DOM
4. **not exist** - Проверка на то, нет ли элемент в DOM
5. **visible** - Проверка на то, виден ли элемент на странице
6. **not visible** - Проверка на то, НЕ виден ли элемент на странице
7. **get_text** - Получить текст элемента
8. **click** - Кликнуть на элемент
9. **click_force** - Кликнуть на элемент принудительно (если элемент скрыт, или элемент не кликабельный)
10. **send_keys** - Ввести текст
11. **clear** - Очистить текстовое поле
12. **get_attribute** - Получение атрибута элемента

### Задача 1
В файле **test_check_text.py** реализуйте тест кейс **def test_page_elements(browser)**:
1. Перейти на страницу 'https://demoqa.com/elements'
   1. Создайте объект страницы
   2. От объекта вызовите метод входа на страницу
2. Проверить, что текст по центру == 'Please select an item from left to start practice.'
   1. Создайте новый объект элемента в классе страницы.
   2. В тесте сделайте проверку:
      1. Обратитесь к странице (к новому элементу) и вызовите метод получения текста.
      2. Сравните полученный текст с эталонным.

### Задача 2
1. Создать текст кейс test_page_elements(browser), добавить следующие проверки:
   (P.S. Новые проверки можно добавлять сразу после предыдущих, если это позволяет логика теста).
   1. Создать объект страницы elements и посетить его.
   2. Проверка наличия иконки:
      1. Вызвать метод .exist() для иконки на странице
      2. Иконку нужно добавить в элементы страницы, если её нет.
   3. Проверка на наличие первой кнопки сайдбара:
      1. Вызвать метод .exist() для кнопки на странице
      2. Кнопку нужно добавить в элементы страницы btn_sidebar_first
      3. Локатор кнопки будет следующий div:nth-child(1) > span > div
   4. Проверка на наличие первой вложенной кнопки сайдбара:
      1. Вызвать метод .exit() для кнопки на странице
      2. Кнопку нужно добавить в элементы страницы btn_sidebar_first_textbox
      3. Локатор кнопки будет следующий div:nth-child(1) > div > ul > #item-0 > span

### Видимость элемента
Часто нам требуется проверить не только наличие элемента на странице, но и его видимость. 

### Задача 3
Напишем пример такой ситуации:
1. Создайте тестовый файл test_visible.py
2. Добавьте тест кейс test_visible_btn_sidebar():
   1. Перейти на страницу 'https://demoqa.com/elements':
      1. Импортируйте класс страницы
      2. Создайте объект страницы
      3. От объекта вызовите метод входа на страницу
   2. Нажать на первую кнопку сайдбара:
      1. Вызовите метод .click() для кнопки. Кнопка уже есть в элементах страницы.
   3. После чего поставьте явное ожидание time.sleep(3)
      1. Для этого импортируйте time
   4. Проверьте наличие кнопки btn_sidebar_first_textbox:
      1. Вызовите метод .exist() для кнопки
   5. Запустите тест 
   6. Тест проходит, но на странице элемента нет, т.к. сайдбар свёрнут. Это можно наблюдать визуально.

### Метод .is_displayed()
В Selenium есть возможность проверить виден элемент на странице или нет.
Метод .is_displayed() - возвращает логическое значение, виден элемент или нет.
Вызывается от метода поиска элемента:
      
      driver.findElement(By.<LocatorStrategy>("Locator")).isDisplayed()  

Важно: Функция отработает всегда, когда элемент виден на странице, даже если он не находится в области видимости окна. Т.е. если мы находимся сверху, а элемент в футере и виден, то функция его найдёт.

### Задача 4: 
Реализуйте следующий тест кейс:
1. В классе компонентов WebElement (файл components.py) добавьте метод visible, который:
   1. Метод принимает только self
   2. В теле метод возвращает .is_displayed(), взятую от элемента - self.find_element()
2. Откройте файл test_visible.py
3. В кейсе test_visible_btn_sidebar закомментируйте проверку (последняя строка)
4. Добавьте новую проверку, ... btn_sidebar_first_textbox.visible()
5. Запустите -> ТЕСТ ДОЛЖЕН УПАСТЬ!
6. Закомментируйте клик по первой кнопку и опять запустите - ТЕСТ ДОЛЖЕН ПРОЙТИ
7. Удалите неиспользуемый код:
   1. Комментарии
   2. Ожидание (импорт оставьте)

### Метод .not_visible()
Проверка на то, что элемент НЕ виден на странице.

Как мы можем реализовать эту проверку, с текущим набором методов?

Так как метод .is_displayed() возвращает логическое значение, мы можем проверить элемент на НЕ видимость просто добавив отрицание в проверку:
      
      assert not elements_page.btn_sidebar_first_textbox.visible()  

### Задача 5:
В том же тестовом файле добавьте тест кейс test_not_visible_btn_sidebar(browser):
1. Перейти на страницу 'https://demoqa.com/elements':
   1. Создайте объект страницы
   2. От объекта вызовите метод входа на страницу
2. Проверьте, что элемент dev:nth-child(1) > div > ul > #item-1 > span виден:
   1. Создайте элемент в классе страницы ElementsPage
   2. Элемент назовите btn_sidebar_first_checkbox
   3. Локатор отличается 1-й цифрой, можете скопировать из похожего элемента
   4. Вызовите метод .visible() для созданной кнопки
3. Нажмите на первую кнопку сайдбара, подождите 2 секунды:
   1. Вызовите метод .click() для кнопки btn_sidebar_first
   2. Пропишите ожидание
4. Проверьте, что элемент не виден:
   1. Вызовите метод .visible() для созданной кнопки
   2. В проверку добавьте отрицание
5. Запустите наш тест

### Задача 6:
Добавьте следующие методы в Базовый класс:
1. Метод **back** (после метода visit), метод принимает только self, в теле:
   1. self.driver.back()
2. Метод **forward** (после метода back), метод принимает только self, в теле:
   1. self.driver.forward()
3. Метод **refresh** (после метода froward), метод принимает только self, в теле:
   1. self.driver.refresh()
4. Метод **get_title** (после метода get_url), метод принимает только self, в теле:
   1. return self.driver.title
