# Урок 11

## Комбинирование методов взаимодействия с DOM

### Решение задачи из домашнего задания №10 (drop-downs).
Есть 3 варианта решения.

### Способ №1 решения задачи с выпадающем меню:
1. Клик по кнопке селекта
2. Клик по элементу списка

        def test_state_1(browser):
            form_page = FormPage(browser)

            form_page.visit()
            time.sleep(2)
            form_page.btn_state.scroll_to_element()
            form_page.btn_state.click()
            form_page.btn_NCR.click()
            time.sleep(2)

### Способ №2 решения задачи с выпадающем меню:
        def test_state_2(browser):
            form_page = FormPage(browser)
        
            form_page.visit()
            time.sleep(2)
            form_page.btn_state.scroll_to_element()
            time.sleep(2)
            form_page.inp_state.send_keys('NCR')
            form_page.inp_state.send_keys(Keys.ENTER)
            time.sleep(2)

### Способ №3 решения задачи с выпадающем меню:
        def test_state_3(browser):
            form_page = FormPage(browser)
            
            form_page.visit()
            time.sleep(2)
            form_page.btn_state.scroll_to_element()
            time.sleep(2)
            form_page.btn_state.click()
            form_page.inp_state.send_keys(Keys.PAGE_DOWN)
            form_page.inp_state.send_keys(Keys.ENTER)
            time.sleep(2)

###  Задача №1
1. Создайте тестовую папку test_koup
2. В файле test_btn_add.py реализуйте следующий тест кейс:
   1. **When** Открыта страница http://the-internet.herokuapp.com/
   2. **Then** На странице имеется ссылка "Add/Remove Elements"
   3. **When** Перейти по ссылке
   4. **Then** Открывается страница http://the-internet.herokuapp.com/add_remove_elements/
   5. **Then** На странице имеется кнопка с текстом "Add Element"
   6. **AND** С атрибутом 'onclick="addElement()"'
   7. **When** Кликнуть на кнопку 4 раза
   8. **Then** Появляются 4 кнопки с текстом "Delete"
   9. **When** Кликнуть на каждую кнопку "Delete"
   10. **Then** все кнопки "Delete" пропадают
   
### Check Style CSS
CSS - это стили, которые делают страницу более привлекательной. Стили также можно получить со страницы, т.е. их можно и нужно проверять.

### Задача №2 (работа со стилями)
1. В классе компонентов создайте метод:
   1. Метод возвращает True, если у элемента есть стиль с указанным значением и False в обратном случае.
2. Создайте тестовый файл test_css.py, в нём тест кейс test_text_box_submit(browser):
   1. Сделайте вход на страницу TextBox
   2. Сделайте проверку:
      1. Обратитесь к кнопке submit и вызовите .check_css('color', 'rgba(255,255,255,1)')
   3. Запустите тест кейс

#### Важно (про названия стилей)
Название стилей в CSS (то, что мы видим в браузере) пришеся так:
1. color
2. background-color
3. border-color
4. Но мы будем проверять по JavaScript, а JS не принимает дефисы.

Поэтому те же названия в JS будут выглядеть следующим образом:
1. color
2. backgroundColor
3. borderColor
Каждое новое слово пишется слитно и с заглавной буквы (camelCase)
Т.е., например, при поиске **background-color** мы будем передавать в метод **backgroundColor**

### Задача №2.1 (добавить новые проверки)
1. Добавить в предыдущий тест кейс новый проверки:
   1. background-color
   2. border-color

### Задача №3 Реализовать Тест Кейс
1. В файле test_webtables.py реализуйте тест кейс:
   1. Перейти на страницу demoqa.com/webtables
   2. **When** В таблице есть записи
   3. **Then** В таблице отсутствует блок "No rows found" - локатор "div.rt-noData"
   4. **When** Удалить все строки в таблице
   5. **Then** В таблице отображается блок "No rows found"

### Диалоговые окна - alert, prompt и confirm
1. **alert** - выводит сообщение
2. **prompt** - выводит сообщение и ждёт, пока пользователь введёт текст, а затем возвращает введённое значение или null, если ввод был отменён (CANCEL/Esc)
3. **confirm** - выводит сообщение и ждёт, пока пользователь нажмёт "ОК" или "CANCEL" и возвращает True/False

Диалоговые окна не являются частью страницы. Они являются частью браузера.
Такое окно всегда одно на странице, даже если их несколько они вызываются асинхронно, что позволяет нам работать одним методом со всеми типами окон.
В Selenium для этого существует метод:
**browser.switch_to.alert**
Метод возвращает объект окна.

### Метод switch_alert()
Добавим метод alert в базовый класс страниц.
Метод принимает только self и возвращает получение объекта окна browser.switch_to.alert

      def alert(self):
         teturn self.driver.switch_to.alert

Такой метод позволяет нам проверить открыть ли алерт  и даёт возможность работать с окном, но не позволяет проверить, что окно НЕ открыто.
Нам необходимо дополнить этот метод:
      
      import logging

      def alert(self):
         try:
            return self.driver.switch_to.alert
         except Exception as ex:
            logging.log(1, ex)
            return False